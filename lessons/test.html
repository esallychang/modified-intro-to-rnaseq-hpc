<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Quality control using FASTQC | GitHub Pages Test</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Quality control using FASTQC" />
<meta name="author" content="Mary Piper, Radhika Khetani" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction to bulk RNA-seq" />
<meta property="og:description" content="Introduction to bulk RNA-seq" />
<link rel="canonical" href="https://esallychang.github.io/modified-intro-to-rnaseq-hpc/lessons/test.html" />
<meta property="og:url" content="https://esallychang.github.io/modified-intro-to-rnaseq-hpc/lessons/test.html" />
<meta property="og:site_name" content="GitHub Pages Test" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-09-20T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Quality control using FASTQC" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Mary Piper, Radhika Khetani"},"dateModified":"2017-09-20T00:00:00+00:00","datePublished":"2017-09-20T00:00:00+00:00","description":"Introduction to bulk RNA-seq","headline":"Quality control using FASTQC","mainEntityOfPage":{"@type":"WebPage","@id":"https://esallychang.github.io/modified-intro-to-rnaseq-hpc/lessons/test.html"},"url":"https://esallychang.github.io/modified-intro-to-rnaseq-hpc/lessons/test.html"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="preload" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700&display=swap" as="style" type="text/css" crossorigin>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="/modified-intro-to-rnaseq-hpc/assets/css/style.css?v=b507c6c38fbc65ecc2e6abea386dbda0aeab8b3b">
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/modified-intro-to-rnaseq-hpc/favicon.ico" -->

<!-- end custom head snippets -->

  </head>
  <body>
    <a id="skip-to-content" href="#content">Skip to the content.</a>

    <header class="page-header" role="banner">
      <h1 class="project-name">Quality control using FASTQC</h1>
      <h2 class="project-tagline">Introduction to bulk RNA-seq</h2>
      
        <a href="https://github.com/esallychang/modified-intro-to-rnaseq-hpc" class="btn">View on GitHub</a>
      
      
    </header>

    <main id="content" class="main-content" role="main">
      <h2 id="learning-objectives">Learning Objectives:</h2>

<ul>
  <li>Evaluate the quality of your NGS data using FastQC</li>
  <li>Create and run a job submission script to automate quality assessment</li>
</ul>

<h2 id="quality-control-of-fastq-files">Quality Control of FASTQ files</h2>

<p><img src="../img/QC_workflow_Sept2018.png" width="400" /></p>

<p>The first step in the RNA-Seq workflow is to take the FASTQ files received from the sequencing facility and assess the quality of the sequence reads.</p>

<h3 id="unmapped-read-data-fastq">Unmapped read data (FASTQ)</h3>

<p>The <a href="https://en.wikipedia.org/wiki/FASTQ_format">FASTQ</a> file format is the defacto file format for sequence reads generated from next-generation sequencing technologies. This file format evolved from FASTA in that it contains sequence data, but also contains quality information. Similar to FASTA, the FASTQ file begins with a header line. The difference is that the FASTQ header is denoted by a <code class="language-plaintext highlighter-rouge">@</code> character. For a single record (sequence read) there are four lines, each of which are described below:</p>

<table>
  <thead>
    <tr>
      <th>Line</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Always begins with ‘@’ and then information about the read</td>
    </tr>
    <tr>
      <td>2</td>
      <td>The actual DNA sequence</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Always begins with a ‘+’ and sometimes the same info in line 1</td>
    </tr>
    <tr>
      <td>4</td>
      <td>Has a string of characters which represent the quality scores; must have same number of characters as line 2</td>
    </tr>
  </tbody>
</table>

<p>Let’s use the following read as an example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@HWI-ST330:304:H045HADXX:1:1101:1111:61397
CACTTGTAAGGGCAGGCCCCCTTCACCCTCCCGCTCCTGGGGGANNNNNNNNNNANNNCGAGGCCCTGGGGTAGAGGGNNNNNNNNNNNNNNGATCTTGG
+
@?@DDDDDDHHH?GH:?FCBGGB@C?DBEGIIIIAEF;FCGGI#########################################################
</code></pre></div></div>

<p>As mentioned previously, line 4 has characters encoding the quality of each nucleotide in the read. The legend below provides the mapping of quality scores (Phred-33) to the quality encoding characters. <em>Different quality encoding scales exist (differing by offset in the ASCII table), but note the most commonly used one is fastqsanger.</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Quality encoding: !"#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHI
                   |         |         |         |         |
    Quality score: 0........10........20........30........40                                
</code></pre></div></div>

<p>Using the quality encoding character legend, the first nucelotide in the read (C) is called with a quality score of 31 and our Ns are called with a score of 2. <strong>As you can tell by now, this is a bad read.</strong></p>

<p>Each quality score represents the probability that the corresponding nucleotide call is incorrect. This quality score is logarithmically based and is calculated as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q = -10 x log10(P), where P is the probability that a base call is erroneous
</code></pre></div></div>

<p>These probabaility values are the results from the base calling algorithm and dependent on how much signal was captured for the base incorporation. The score values can be interpreted as follows:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Phred Quality Score</th>
      <th style="text-align: center">Probability of incorrect base call</th>
      <th style="text-align: right">Base call accuracy</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">10</td>
      <td style="text-align: center">1 in 10</td>
      <td style="text-align: right">90%</td>
    </tr>
    <tr>
      <td style="text-align: left">20</td>
      <td style="text-align: center">1 in 100</td>
      <td style="text-align: right">99%</td>
    </tr>
    <tr>
      <td style="text-align: left">30</td>
      <td style="text-align: center">1 in 1000</td>
      <td style="text-align: right">99.9%</td>
    </tr>
    <tr>
      <td style="text-align: left">40</td>
      <td style="text-align: center">1 in 10,000</td>
      <td style="text-align: right">99.99%</td>
    </tr>
  </tbody>
</table>

<p>Therefore, for the first nucleotide in the read (C), there is less than a 1 in 1000 chance that the base was called incorrectly. Whereas, for the the end of the read there is greater than 50% probabaility that the base is called incorrectly.</p>

<h2 id="assessing-quality-with-fastqc">Assessing quality with FastQC</h2>

<p>Now we understand what information is stored in a FASTQ file, the next step is to examine quality metrics for our data.</p>

<p><a href="http://www.bioinformatics.babraham.ac.uk/projects/fastqc/">FastQC</a> provides a simple way to do some quality control checks on raw sequence data coming from high throughput sequencing pipelines. It provides a modular set of analyses which you can use to give a quick impression of whether your data has any problems of which you should be aware before doing any further analysis.</p>

<p>The main functions of FastQC are:</p>

<ul>
  <li>Import of data from BAM, SAM or FastQ files (any variant)</li>
  <li>Providing a quick overview to tell you in which areas there may be problems</li>
  <li>Summary graphs and tables to quickly assess your data</li>
  <li>Export of results to an HTML based permanent report</li>
  <li>Offline operation to allow automated generation of reports without running the interactive application</li>
</ul>

<h3 id="run-fastqc">Run FastQC</h3>

<p>Before we run FastQC, let’s start an interactive session on the cluster (if you don’t already have one going):</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>srun <span class="nt">--pty</span> <span class="nt">-p</span> interactive <span class="nt">-t</span> 0-12:00 <span class="nt">--mem</span> 8G <span class="nt">--reservation</span><span class="o">=</span>HBC1 /bin/bash
</code></pre></div></div>

<p><strong><em>An interactive session is very useful to test tools, workflows, run jobs that open new interactive windows (X11-forwarding) and so on.</em></strong></p>

<p>Once your interactive job starts, notice that the command prompt has changed; this is because we are working on a compute node now, not on a login node. Change directories to <code class="language-plaintext highlighter-rouge">raw_data</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd</span> ~/rnaseq/raw_data
</code></pre></div></div>

<p>Before we start using software, we have to load the environments for each software package. On the O2 cluster, this is done using an <strong>LMOD</strong> system.</p>

<p>If we check which modules we currently have loaded, we should not see FastQC.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>module list
</code></pre></div></div>

<p>This is because the FastQC program is not in our $PATH (i.e. its not in a directory that unix will automatically check to run commands/programs).</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$PATH</span>
</code></pre></div></div>

<p>To run the FastQC program, we first need to load the appropriate module, so it puts the program into our path. To find the FastQC module to load we need to search the versions available:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>module spider
</code></pre></div></div>

<p>Then we can load the FastQC module:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>module load fastqc/0.11.3
</code></pre></div></div>

<p>Once a module for a tool is loaded, you have essentially made it directly available to you like any other basic UNIX command.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>module list

<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$PATH</span>
</code></pre></div></div>

<p>FastQC will accept multiple file names as input, so we can use the <code class="language-plaintext highlighter-rouge">*.fq</code> wildcard.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>fastqc <span class="k">*</span>.fq
</code></pre></div></div>

<p><em>Did you notice how each file was processed serially? How do we speed this up?</em></p>

<p>Exit the interactive session and start a new one with 6 cores, and use the multi-threading functionality of FastQC to run 6 jobs at once.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">exit</span>  <span class="c">#exit the current interactive session</span>

<span class="nv">$ </span>srun <span class="nt">--pty</span> <span class="nt">-n</span> 6 <span class="nt">-p</span> interactive <span class="nt">-t</span> 0-12:00 <span class="nt">--mem</span> 8G <span class="nt">--reservation</span><span class="o">=</span>HBC1 /bin/bash  <span class="c">#start a new one with 6 cpus (-n 6) and 8G RAM (--mem 8G)</span>

<span class="nv">$ </span>module load fastqc/0.11.3  <span class="c">#reload the module for the new session</span>

<span class="nv">$ </span><span class="nb">cd</span> ~/rnaseq/raw_data

<span class="nv">$ </span>fastqc <span class="nt">-t</span> 6 <span class="k">*</span>.fq  <span class="c">#note the extra parameter we specified for 6 threads</span>
</code></pre></div></div>

<p>How did I know about the -t argument for FastQC?</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>fastqc <span class="nt">--help</span>
</code></pre></div></div>

<p>Now, let’s create a home for our results</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">mkdir</span> ~/rnaseq/results/fastqc
</code></pre></div></div>

<p>…and move them there (recall, we are still in <code class="language-plaintext highlighter-rouge">~/rnaseq/raw_data/</code>)</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">mv</span> <span class="k">*</span>fastqc<span class="k">*</span> ~/rnaseq/results/fastqc/
</code></pre></div></div>

<h3 id="performing-quality-assessment-using-job-submission-scripts">Performing quality assessment using job submission scripts</h3>
<p>So far in our FASTQC analysis, we have been directly submitting commands to O2 using an interactive session (ie. <code class="language-plaintext highlighter-rouge">srun --pty -n 6 -p short -t 0-12:00 --mem 8G bash</code>). However, there are many more partitions available on O2 than just the interactive partition. We can submit commands or series of commands to these partitions using job submission scripts.</p>

<p><strong>Job submission scripts</strong> for O2 are just regular scripts, but contain the O2 <strong>options/directives</strong> for job submission, such as <em>number of cores, name of partition, runtime limit, etc</em>. We can submit these scripts to whichever partition we specify in the script using the <code class="language-plaintext highlighter-rouge">sbatch</code> command as follows:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># DO NOT RUN THIS</span>
<span class="nv">$ </span>sbatch job_submission_script.run
</code></pre></div></div>

<p>Submission of the script using the <code class="language-plaintext highlighter-rouge">sbatch</code> command allows SLURM to run your job when its your turn. Let’s create a job submission script to load the FASTQC module, run FASTQC on all of our fastq files, and move the files to the appropriate directory.</p>

<p>Change directories to <code class="language-plaintext highlighter-rouge">~/rnaseq/scripts</code>, and create a script named <code class="language-plaintext highlighter-rouge">mov10_fastqc.run</code> using <code class="language-plaintext highlighter-rouge">vim</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd</span> ~/rnaseq/scripts

<span class="nv">$ </span>vim mov10_fastqc.run
</code></pre></div></div>

<p>The first thing we need in our script is the <strong>shebang line</strong>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
</code></pre></div></div>

<p>Following the shebang line are the O2 options. For the script to run, we need to include options for <strong>queue/partition (-p) and runtime limit (-t)</strong>. To specify our options, we precede the option with <code class="language-plaintext highlighter-rouge">#SBATCH</code>, which tells O2 that the line contains options for job submission to SLURM.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#SBATCH -p short 		# partition name</span>
<span class="c">#SBATCH -t 0-2:00 		# hours:minutes runlimit after which job will be killed</span>
<span class="c">#SBATCH -n 6 		# number of cores requested -- this needs to be greater than or equal to the number of cores you plan to use to run your job</span>
<span class="c">#SBATCH --job-name rnaseq_mov10_fastqc 		# Job name</span>
<span class="c">#SBATCH -o %j.out			# File to which standard out will be written</span>
<span class="c">#SBATCH -e %j.err 		# File to which standard err will be written</span>
</code></pre></div></div>
<p>Now in the body of the script, we can include any commands we want run:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">## Changing directories to where the fastq files are located</span>
<span class="nb">cd</span> ~/rnaseq/raw_data

<span class="c">## Loading modules required for script commands</span>
module load fastqc/0.11.3

<span class="c">## Running FASTQC</span>
fastqc <span class="nt">-t</span> 6 <span class="k">*</span>.fq

<span class="c">## Moving files to our results directory</span>
<span class="nb">mv</span> <span class="k">*</span>fastqc<span class="k">*</span> ../results/fastqc/
</code></pre></div></div>

<p>Save and quit the script. Now, let’s submit the job to the SLURM:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>sbatch mov10_fastqc.run
</code></pre></div></div>

<p>You can check on the status of your job with:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>sacct
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-lh</span> ../results/fastqc/
</code></pre></div></div>
<p>There should also be standard error (<code class="language-plaintext highlighter-rouge">.err</code>) and standard out (<code class="language-plaintext highlighter-rouge">.out</code>) files from the job listed in <code class="language-plaintext highlighter-rouge">~/rnaseq/scripts</code>. You can move these over to your <code class="language-plaintext highlighter-rouge">logs</code> directory and give them more intuitive names:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">mv</span> <span class="k">*</span>.err ../logs/fastqc.err
<span class="nv">$ </span><span class="nb">mv</span> <span class="k">*</span>.out ../logs/fastqc.out
</code></pre></div></div>

<hr />
<p><strong>Exercise</strong></p>

<p>How would you change the <code class="language-plaintext highlighter-rouge">mov10_fastqc.run</code> script if you had 9 fastq files you wanted to run in parallel.</p>

<hr />

<h3 id="fastqc-results">FastQC Results</h3>

<p>Let’s take a closer look at the files generated by FastQC:</p>

<p><code class="language-plaintext highlighter-rouge">$ ls -lh ~/rnaseq/results/fastqc/</code></p>

<h4 id="html-reports">HTML reports</h4>
<p>The .html files contain the final reports generated by fastqc, let’s take a closer look at them. Transfer the file for <code class="language-plaintext highlighter-rouge">Mov10_oe_1.subset.fq</code> over to your laptop via <em>FileZilla</em>.</p>

<h5 id="filezilla---step-1">Filezilla - Step 1</h5>

<p>Open <em>FileZilla</em>, and click on the File tab. Choose ‘Site Manager’.</p>

<p><img src="/modified-intro-to-rnaseq-hpc/img/Filezilla_step1.png" alt="FileZilla_step1" /></p>

<h5 id="filezilla---step-2">Filezilla - Step 2</h5>

<p>Within the ‘Site Manager’ window, do the following:</p>

<ol>
  <li>Click on ‘New Site’, and name it something intuitive (e.g. O2)</li>
  <li>Host: transfer.rc.hms.harvard.edu</li>
  <li>Protocol: SFTP - SSH File Transfer Protocol</li>
  <li>Logon Type: Normal</li>
  <li>User: ECommons ID</li>
  <li>Password: ECommons password</li>
  <li>Click ‘Connect’</li>
</ol>

<p><img src="../img/Filezilla_step2.png" width="500" /></p>

<p><strong><em>FastQC is just an indicator of what’s going on with your data, don’t take the “PASS”es and “FAIL”s too seriously.</em></strong></p>

<p>FastQC has a really well documented <a href="http://www.bioinformatics.babraham.ac.uk/projects/fastqc/">manual page</a> with <a href="http://www.bioinformatics.babraham.ac.uk/projects/fastqc/Help/">more details</a> about all the plots in the report. We recommend looking at <a href="http://bioinfo-core.org/index.php/9th_Discussion-28_October_2010">this post</a> for more information on what bad plots look like and what they mean for your data.</p>

<blockquote>
  <p><strong>We also have a <a href="https://github.com/hbctraining/Intro-to-rnaseq-hpc-O2/raw/master/lectures/error_profiles_mm.pdf">slidedeck</a> of error profiles for Illumina sequencing, where we discuss specific FASTQC plots and possible sources of these types of errors.</strong></p>
</blockquote>

<p>Below are two of the most important analysis modules in FastQC, the <strong>“Per base sequence quality”</strong> plot and the <strong>“Overrepresented sequences”</strong> table.</p>

<p>The <strong>“Per base sequence quality”</strong> plot provides the distribution of quality scores across all bases at each position in the reads.</p>

<p><img src="/modified-intro-to-rnaseq-hpc/img/FastQC_seq_qual.png" alt="FastQC_seq_qual" /></p>

<p>The <strong>“Overrepresented sequences”</strong> table displays the sequences (at least 20 bp) that occur in more than 0.1% of the total number of sequences. This table aids in identifying contamination, such as vector or adapter sequences.</p>

<p><img src="/modified-intro-to-rnaseq-hpc/img/FastQC_contam.png" alt="FastQC_contam" /></p>

<p>We will go over the remaining plots in class. Remember, our report only represents a subset of reads (chromosome 1) for <code class="language-plaintext highlighter-rouge">Mov10_oe_1.subset.fq</code>, which can skew the QC results. We encourage you to look at the <a href="/modified-intro-to-rnaseq-hpc/fastqc/Mov10oe_1-fastqc_report.html">full set of reads</a> and note how the QC results differ when using the entire dataset.</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> 
The other output of FastQC is a .zip file. These .zip files need to be unpacked with the <code class="language-plaintext highlighter-rouge">unzip</code> program. If we try to <code class="language-plaintext highlighter-rouge">unzip</code> them all at once:</p>

  <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd</span> ~/rnaseq/results/fastqc/    
<span class="nv">$ </span>unzip <span class="k">*</span>.zip
</code></pre></div>  </div>

  <p>Did it work?</p>

  <p>No, because <code class="language-plaintext highlighter-rouge">unzip</code> expects to get only one zip file. Welcome to the real world.
We <em>could</em> do each file, one by one, but what if we have 500 files? There is a smarter way.
We can save time by using a simple shell <code class="language-plaintext highlighter-rouge">for loop</code> to iterate through the list of files in *.zip.</p>

  <p>After you type the first line, you will get a special ‘&gt;’ prompt to type next lines.<br />
You start with ‘do’, then enter your commands, then end with ‘done’ to execute the loop.</p>

  <p>Note that in the first line, we create a variable named <code class="language-plaintext highlighter-rouge">zip</code>.  After that, we call that variable with the syntax <code class="language-plaintext highlighter-rouge">$zip</code>. <code class="language-plaintext highlighter-rouge">$zip</code> is assigned the value of each item (file) in the list *.zip, once for each iteration of the loop.</p>

  <p>This loop is basically a simple program. When it runs</p>

  <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="k">for </span>zip <span class="k">in</span> <span class="k">*</span>.zip
<span class="k">do
</span>unzip <span class="nv">$zip</span>
<span class="k">done</span>
</code></pre></div>  </div>
  <p>This will run unzip once for each file (whose name is stored in the $zip variable). The contents of each file will be unpacked into a separate directory by the unzip program.</p>

  <p>The ‘for loop’ is interpreted as a multipart command.  If you press the up arrow on your keyboard to recall the command, it will be shown like so:</p>

  <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for </span>zip <span class="k">in</span> <span class="k">*</span>.zip<span class="p">;</span> <span class="k">do </span>unzip <span class="nv">$zip</span><span class="p">;</span> <span class="k">done</span>
</code></pre></div>  </div>

  <p>When you check your history later, it will help you remember what you did!</p>

  <p>What information is contained in the unzipped folder?</p>

  <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-lh</span> Mov10_oe_1.subset_fastqc
<span class="nv">$ </span><span class="nb">head </span>Mov10_oe_1.subset_fastqc/summary.txt
</code></pre></div>  </div>

  <p>To save a record, let’s <code class="language-plaintext highlighter-rouge">cat</code> all <code class="language-plaintext highlighter-rouge">fastqc summary.txt</code> files into one <code class="language-plaintext highlighter-rouge">full_report.txt</code> and move this to <code class="language-plaintext highlighter-rouge">~/rnaseq/docs</code>. 
You can use wildcards in paths as well as file names.  Do you remember how we said <code class="language-plaintext highlighter-rouge">cat</code> is really meant for concatenating text files?</p>

  <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat</span> <span class="k">*</span>/summary.txt <span class="o">&gt;</span> ~/rnaseq/logs/fastqc_summaries.txt
</code></pre></div>  </div>
</blockquote>

<h2 id="quality-control-optional---trimming">Quality Control (<em>Optional</em>) - Trimming</h2>

<p>We want to make sure that as many reads as possible map or align accurately to the genome. To ensure accuracy, only a small number of mismatches between the read sequence and the genome sequence are allowed, and any read with more than a few mismatches will be marked as being unaligned.</p>

<p>Therefore, to make sure that all the reads in the dataset have a chance to map/align to the genome, unwanted information can be trimmed off from every read, one read at a time. The types of unwanted information can include one or more of the following:</p>
<ul>
  <li>leftover adapter sequences</li>
  <li>known contaminants (strings of As/Ts, other sequences)</li>
  <li>poor quality bases at read ends</li>
</ul>

<p><strong>We will not be performing this step</strong> because:</p>
<ul>
  <li>our data does not have an appreciable amount of leftover adapter sequences or other contaminating sequences based on FastQC.</li>
  <li>the alignment tool we have picked (STAR) is able to account for low-quality bases at the ends of reads when matching them to the genome.</li>
</ul>

<p>If you need to perform trimming on your fastq data to remove unwanted sequences/bases, the recommended tool is <a href="http://cutadapt.readthedocs.io/en/stable/index.html">cutadapt</a>.</p>

<p>Example of cutadapt usage:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>cutadapt <span class="nt">--adapter</span><span class="o">=</span>AGATCGGAAGAG <span class="nt">--minimum-length</span><span class="o">=</span>25  <span class="nt">-o</span> myfile_trimmed.fastq.gz myfile.fastq.gz 
</code></pre></div></div>

<p>After trimming, cutadapt can remove any reads that are too short to ensure that you do not get spurious mapping of very short sequences to multiple locations on the genome. In addition to adapter trimming, cutadapt can trim off any low-quality bases too, but <strong>please note that quality-based trimming is not considered best practice, since majority of the newer, recommended alignment tools can account for this.</strong></p>

<hr />
<p><em>This lesson has been developed by members of the teaching team at the <a href="http://bioinformatics.sph.harvard.edu/">Harvard Chan Bioinformatics Core (HBC)</a>. These are open access materials distributed under the terms of the <a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution license</a> (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</em></p>

<ul>
  <li><em>The materials used in this lesson was derived from work that is Copyright © Data Carpentry (http://datacarpentry.org/). 
All Data Carpentry instructional material is made available under the <a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution license</a> (CC BY 4.0).</em></li>
</ul>


      <footer class="site-footer">
        
          <span class="site-footer-owner"><a href="https://github.com/esallychang/modified-intro-to-rnaseq-hpc">modified-intro-to-rnaseq-hpc</a> is maintained by <a href="https://github.com/esallychang">esallychang</a>.</span>
        
        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span>
      </footer>
    </main>
  </body>
</html>
