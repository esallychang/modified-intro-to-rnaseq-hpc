<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Automating the RNA-seq workflow | GitHub Pages Test</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Automating the RNA-seq workflow" />
<meta name="author" content="Meeta Mistry, Radhika Khetani, Mary Piper, Jihe Liu, Edited by Sally Chang @ NICHD" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction to bulk RNA-seq" />
<meta property="og:description" content="Introduction to bulk RNA-seq" />
<link rel="canonical" href="https://esallychang.github.io/branched-docs-demo/modified-intro-apr2025/lessons/12_automating_workflow.html" />
<meta property="og:url" content="https://esallychang.github.io/branched-docs-demo/modified-intro-apr2025/lessons/12_automating_workflow.html" />
<meta property="og:site_name" content="GitHub Pages Test" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-10-15T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Automating the RNA-seq workflow" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Meeta Mistry, Radhika Khetani, Mary Piper, Jihe Liu, Edited by Sally Chang @ NICHD"},"dateModified":"2024-10-15T00:00:00+00:00","datePublished":"2024-10-15T00:00:00+00:00","description":"Introduction to bulk RNA-seq","headline":"Automating the RNA-seq workflow","mainEntityOfPage":{"@type":"WebPage","@id":"https://esallychang.github.io/branched-docs-demo/modified-intro-apr2025/lessons/12_automating_workflow.html"},"url":"https://esallychang.github.io/branched-docs-demo/modified-intro-apr2025/lessons/12_automating_workflow.html"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="preload" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700&display=swap" as="style" type="text/css" crossorigin>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="/branched-docs-demo/modified-intro-apr2025/assets/css/style.css?v=55b8125905b1663ec73ee9c29b169c4ffd03076a">
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/branched-docs-demo/modified-intro-apr2025/favicon.ico" -->

<!-- end custom head snippets -->

  </head>
  <body>
    <a id="skip-to-content" href="#content">Skip to the content.</a>

    <header class="page-header" role="banner">
      <h1 class="project-name">Automating the RNA-seq workflow</h1>
      <h2 class="project-tagline">Introduction to bulk RNA-seq</h2>
      
        <a href="https://github.com/esallychang/modified-intro-to-rnaseq-hpc" class="btn">View on GitHub</a>
      
      
    </header>

    <main id="content" class="main-content" role="main">
      <h2 id="learning-objectives">Learning Objectives:</h2>

<ul>
  <li>Create a reusable and efficient workflow for RNA-seq data analysis using shell scripts</li>
</ul>

<h2 id="automating-the-analysis-path-from-sequence-reads-to-count-matrix">Automating the analysis path from Sequence reads to Count matrix</h2>

<p>Once you have optimized all the tools and parameters using a single sample (likely using an interactive session), you can write a script to run the whole workflow on all the samples in parallel.</p>

<p>This will ensure that you run every sample with the exact same parameters, and will enable you to keep track of all the tools and their versions. In addition, the script is like a lab notebook; in the future, you (or your colleagues) can go back and check the workflow for methods, which enables efficiency and reproducibility.</p>

<h3 id="using-scratch-space">Using “scratch space”</h3>

<p>Before we get started, let’s talk a little bit about how data are stored on O2. O2, like many clusters, has several different storage options; each of which has different amounts of space available, and is differently backed up. One filesystem is the <code class="language-plaintext highlighter-rouge">/n/scratch/</code> space. This directory has a lot of shared disk space available, but the files are not backed up and they will be deleted if left “untouched” for more than 30 days. <strong>This is akin to the /scratch/user space on Biowulf, which is not available from a compute node. I will need to adjust this part of the lesson entirely based on what Biowulf recommends. Get students in the practice of writing to /lscratch?</strong></p>

<p>By design <code class="language-plaintext highlighter-rouge">/n/scratch/</code> is to be used for intermediate files that are created during any analysis. An example is in the schematic below.</p>

<p align="center">

<img src="../img/scratch3_best-practice.png" width="600" />

</p>

<p>Today, we are going to learn how to use the <code class="language-plaintext highlighter-rouge">/n/scratch/</code> storage location as we work on automating our workflow (<a href="https://harvardmed.atlassian.net/wiki/spaces/O2/pages/2652045313/Scratch+Storage">More information about scratch space on O2</a>. We will be maintaining our data in our (backed up) home directories, but all of the output files will be in scratch space. When we are done, we can copy over only those output files that are essential.</p>

<h4 id="not-relevant-for-biowulf-creating-a-folder-in-nscratch">Not relevant for Biowulf: Creating a folder in <code class="language-plaintext highlighter-rouge">/n/scratch/</code></h4>

<p>To get started let’s create a folder for ourselves in <code class="language-plaintext highlighter-rouge">/n/scratch/</code> first. We can do so by running the existing script <code class="language-plaintext highlighter-rouge">/n/cluster/bin/scratch_create_directory.sh</code> from a login node.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>sh /n/cluster/bin/scratch_create_directory.sh
</code></pre></div></div>

<p>When you press enter you will see:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Do you want to create a scratch directory under /n/scratch/users? [y/N]&gt;
</code></pre></div></div>

<p>Please say <code class="language-plaintext highlighter-rouge">y</code>. Next, it will display the guidelines for this folder and ask you to verify that you have read them:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Do you want to create a scratch directory under /n/scratch/users? [y/N]&gt; y

By typing 'YES' I will comply with HMS RC guidelines for using Scratch.
I also confirm that I understand that files in my scratch directory WILL NOT BE BACKED UP IN ANY WAY.
I also understand that 45 DAYS after I last modify a given file or directory in my scratch directory,
it will be DELETED with NO POSSIBILITY of retrieval.

I understand HMS RC guidelines for using Scratch: 
</code></pre></div></div>

<p>Please answer <code class="language-plaintext highlighter-rouge">Yes</code> or <code class="language-plaintext highlighter-rouge">yes</code> here, once you do you will get some additional information and your command prompt back.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Your scratch directory was created at /n/scratch/users/r/rc_training01.
This has a limit of 25TiB of storage and 2.5 million files.
You can check your scratch quota using the quota-v2 command.
</code></pre></div></div>

<p>Great, now we all have created a work directory for ourselves in the <code class="language-plaintext highlighter-rouge">/n/scratch/</code> storage space!</p>

<p>Let’s go ahead and create a folder within our <code class="language-plaintext highlighter-rouge">/n/scratch/</code> storage space for the results of our analysis.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> /n/scratch/users/r/<span class="nv">$USER</span>/rnaseq_hbc-workshop
</code></pre></div></div>

<p>When we create our script, we will make sure that all of the analysis output gets saved in the <code class="language-plaintext highlighter-rouge">/n/scratch/users/r/$USER/rnaseq_hbc-workshop</code> folder.</p>

<h3 id="start-an-interactive-session">Start an interactive session</h3>

<p>We will be working with an interactive session with 6 cores.</p>

<blockquote>
  <p>If you have a session with fewer cores then <code class="language-plaintext highlighter-rouge">exit</code> out of your current interactive session and start a new one with <code class="language-plaintext highlighter-rouge">-c 6</code>.</p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>srun <span class="nt">--pty</span> <span class="nt">-p</span> interactive <span class="nt">-t</span> 0-3:00 <span class="nt">-c</span> 6 <span class="nt">--mem</span> 8G <span class="nt">--reservation</span><span class="o">=</span>HBC3 /bin/bash
</code></pre></div></div>

<h3 id="more-flexibility-with-variables">More Flexibility with variables</h3>

<p>We can write a shell script that will run on a specific file, but to make it more flexible and efficient we would prefer that it lets us give it an input fastq file when we run the script. To be able to provide an input to any shell script, we need to use <strong>Positional Parameters</strong>.</p>

<p>For example, we can refer to the components of the following command as numbered variables <strong>within</strong> the actual script:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># * DO NOT RUN *</span>
sh  run_rnaseq.sh  input.fq  input.gtf  12
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">$0</code> =&gt; run_rnaseq.sh</p>

<p><code class="language-plaintext highlighter-rouge">$1</code> =&gt; input.fq</p>

<p><code class="language-plaintext highlighter-rouge">$2</code> =&gt; input.gtf</p>

<p><code class="language-plaintext highlighter-rouge">$3</code> =&gt; 12</p>

<p>The variables <code class="language-plaintext highlighter-rouge">$1</code>, <code class="language-plaintext highlighter-rouge">$2</code>, <code class="language-plaintext highlighter-rouge">$3</code>,…<code class="language-plaintext highlighter-rouge">$9</code> and so on are <strong>positional parameters</strong> in the context of the shell script, and can be used within the script to refer to the files/number specified on the command line. Basically, the script is written with the expectation that <code class="language-plaintext highlighter-rouge">$1</code> will be a fastq file and <code class="language-plaintext highlighter-rouge">$2</code> will be a GTF file, and so on.</p>

<p>Note that <code class="language-plaintext highlighter-rouge">$1</code>, which you may have seen before, is actually a short form of <code class="language-plaintext highlighter-rouge">${1}</code> and we can only use <code class="language-plaintext highlighter-rouge">$1</code> when it is <strong>not</strong> followed by a letter, digit or an underscore but we can always use <code class="language-plaintext highlighter-rouge">${1}</code>. Using <code class="language-plaintext highlighter-rouge">${1}</code> is best practice and what we will use for the rest of this lesson.</p>

<p><em>There can be virtually unlimited numbers of inputs to a shell script, but it is wise to only have a few inputs to avoid errors and confusion when running a script that used positional parameters.</em></p>

<blockquote>
  <p><a href="http://steve-parker.org/sh/eg/var3.sh.txt">This is an example of a simple script that used the concept of positional parameters and the associated variables</a>. You should try this script out after the class to get a better handle on positional parameters for shell scripting. You can also learn more about positional parameters <a href="https://hbctraining.github.io/Training-modules/Intermediate_shell/lessons/positional_params.html">here</a></p>
</blockquote>

<p>We will be using this concept in our automation script, wherein we will accept the full or relative path to a file as input.</p>

<h3 id="writing-the-automation-script">Writing the automation script!</h3>

<p>We will start writing the script on our laptops using a simple text editor like Sublime Text or Notepad++. Let’s being with the shebang line and a <code class="language-plaintext highlighter-rouge">cd</code> command so that our results are all written on <code class="language-plaintext highlighter-rouge">/n/scratch/</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash/</span>

<span class="c"># change directories to /n/scratch/ so that all the analysis is stored there.</span>

<span class="nb">cd</span> /n/scratch/users/r/<span class="nv">$USER</span>/rnaseq_hbc-workshop/
</code></pre></div></div>

<p><strong>We want users to input the path to the fastq file as input to the shell script.</strong> To make this happen, we will use the <code class="language-plaintext highlighter-rouge">${1}</code> positional parameter variable within the script.</p>

<p>Since <code class="language-plaintext highlighter-rouge">${1}</code> will store the path to the fastq file, including the file name, we will be referring to it every time we need to specify the fastq file in any commands. We could just use the variable <code class="language-plaintext highlighter-rouge">${1}</code>, but that is not an intuitive variable name for a fastq file, is it? So we want to create a new variable called <code class="language-plaintext highlighter-rouge">fq</code> and copy the contents of <code class="language-plaintext highlighter-rouge">${1}</code> into it.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># initialize a variable with an intuitive name to store the name of the input fastq file</span>

<span class="nv">fq</span><span class="o">=</span><span class="nv">$1</span>
</code></pre></div></div>

<p>In the rest of the script, we can now call the fastq file using <code class="language-plaintext highlighter-rouge">${fq}</code> instead of <code class="language-plaintext highlighter-rouge">${1}</code>!</p>

<blockquote>
  <p>When we set up variables we do not use the <code class="language-plaintext highlighter-rouge">$</code> before it, but when we <em>use the variable</em>, we always have to have the <code class="language-plaintext highlighter-rouge">$</code> before it. &gt;</p>

  <p>For example:</p>

  <p>initializing the <code class="language-plaintext highlighter-rouge">fq</code> variable =&gt; <code class="language-plaintext highlighter-rouge">fq=$1</code></p>

  <p>using the <code class="language-plaintext highlighter-rouge">fq</code> variable =&gt; <code class="language-plaintext highlighter-rouge">fastqc ${fq}</code></p>
</blockquote>

<p>Next, we want to extract the name of the sample from <code class="language-plaintext highlighter-rouge">${fq}</code> which contains the full name of the file and possibly the path to the file as well. The reason to extract the sample name is so that all the output files from this workflow are appropriately named with sample identifier.</p>

<p>We can obtain the sample name by using the <code class="language-plaintext highlighter-rouge">basename</code> command on the <code class="language-plaintext highlighter-rouge">${fq}</code> (or <code class="language-plaintext highlighter-rouge">${1}</code>) variable, and save it in a new variable called <code class="language-plaintext highlighter-rouge">samplename</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># grab base of filename for naming outputs</span>

<span class="nv">samplename</span><span class="o">=</span><span class="sb">`</span><span class="nb">basename</span> <span class="k">${</span><span class="nv">fq</span><span class="k">}</span> .subset.fq<span class="sb">`</span>
<span class="nb">echo</span> <span class="s2">"Sample name is </span><span class="k">${</span><span class="nv">samplename</span><span class="k">}</span><span class="s2">"</span>           
</code></pre></div></div>

<blockquote>
  <p><strong>Remember <code class="language-plaintext highlighter-rouge">basename</code>?</strong></p>

  <ol>
    <li>the <code class="language-plaintext highlighter-rouge">basename</code> command: this command takes a path or a name and trims away all the information before the last <code class="language-plaintext highlighter-rouge">/</code> and if you specify the string to clear away at the end, it will do that as well. In this case, if the variable <code class="language-plaintext highlighter-rouge">${fq}</code> contains the path <em>”~/rnaseq/raw_data/Mov10_oe_1.subset.fq”</em>, <code class="language-plaintext highlighter-rouge">basename ${fq} .subset.fq</code> will output “Mov10_oe_1”.</li>
    <li>to assign the value of the <code class="language-plaintext highlighter-rouge">basename</code> command to the <code class="language-plaintext highlighter-rouge">samplename</code> variable, we encapsulate the <code class="language-plaintext highlighter-rouge">basename...</code> command in backticks. This syntax is necessary for assigning the output of a command to a variable.</li>
  </ol>
</blockquote>

<p>Next we want to specify how many cores the script should use to run the analysis. This provides us with an easy way to modify the script to run with more or fewer cores without have to replace the number within all commands where cores are specified.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># specify the number of cores to use</span>

<span class="nv">cores</span><span class="o">=</span>6
</code></pre></div></div>

<p>Next we’ll initialize 3 more variables named <code class="language-plaintext highlighter-rouge">genome</code>, <code class="language-plaintext highlighter-rouge">transcriptome</code> and <code class="language-plaintext highlighter-rouge">gtf</code>, these will contain the paths to where the reference files are stored. This makes it easier to modify the script for when you want to use a different genome, i.e. you’ll just have to change the contents of these variable at the beginning of the script.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># directory with the genome and transcriptome index files + name of the gene annotation file</span>

<span class="nv">genome</span><span class="o">=</span>/n/groups/hbctraining/intro_rnaseq_hpc/reference_data_ensembl38/ensembl38_STAR_index
<span class="nv">transcriptome</span><span class="o">=</span>/n/groups/hbctraining/rna-seq_2019_02/reference_data/salmon_index
<span class="nv">gtf</span><span class="o">=</span>/n/groups/hbctraining/intro_rnaseq_hpc/reference_data_ensembl38/Homo_sapiens.GRCh38.92.1.gtf
</code></pre></div></div>

<p>We’ll create output directories, but with the <code class="language-plaintext highlighter-rouge">-p</code> option. This will make sure that <code class="language-plaintext highlighter-rouge">mkdir</code> will create the directory only if it does not exist, and it won’t throw an error if it does exist.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># make all of the output directories</span>
<span class="c"># The -p option means mkdir will create the whole path if it </span>
<span class="c"># does not exist and refrain from complaining if it does exist</span>

<span class="nb">mkdir</span> <span class="nt">-p</span> results/fastqc/
<span class="nb">mkdir</span> <span class="nt">-p</span> results/STAR/
<span class="nb">mkdir</span> <span class="nt">-p</span> results/qualimap/
<span class="nb">mkdir</span> <span class="nt">-p</span> results/salmon/
</code></pre></div></div>

<p>Now that we have already created our output directories, we can now specify variables with the path to those directories both for convenience but also to make it easier to see what is going on in a long command.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># set up output filenames and locations</span>

<span class="nv">fastqc_out</span><span class="o">=</span>results/fastqc/
<span class="nv">align_out</span><span class="o">=</span>results/STAR/<span class="k">${</span><span class="nv">samplename</span><span class="k">}</span>_
<span class="nv">align_out_bam</span><span class="o">=</span>results/STAR/<span class="k">${</span><span class="nv">samplename</span><span class="k">}</span>_Aligned.sortedByCoord.out.bam
<span class="nv">qualimap_out</span><span class="o">=</span>results/qualimap/<span class="k">${</span><span class="nv">samplename</span><span class="k">}</span>.qualimap
<span class="nv">salmon_out</span><span class="o">=</span>results/salmon/<span class="k">${</span><span class="nv">samplename</span><span class="k">}</span>.salmon
<span class="nv">salmon_mappings</span><span class="o">=</span>results/salmon/<span class="k">${</span><span class="nv">samplename</span><span class="k">}</span>_salmon.out
</code></pre></div></div>

<h3 id="keeping-track-of-tool-versions">Keeping track of tool versions</h3>

<p>All of our variables are now staged. Next, let’s make sure all the modules are loaded. This is also a good way to keep track of the versions of tools that you are using in the script:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># set up the software environment (use version numbers)</span>

module load fastqc/0.12.1
module load gcc/6.2.0  
module load star/2.5.4a
module load samtools/1.15.1
module load java/jdk-1.8u112
module load qualimap/2.2.1
module load salmon/1.8.0
<span class="nb">unset </span>DISPLAY
</code></pre></div></div>

<h3 id="preparing-for-future-debugging">Preparing for future debugging</h3>

<p>In the script, it is a good idea to use <code class="language-plaintext highlighter-rouge">echo</code> for debugging. <code class="language-plaintext highlighter-rouge">echo</code> basically displays the string of characters specified within the quotations. When you have strategically place <code class="language-plaintext highlighter-rouge">echo</code> commands specifying what stage of the analysis is next, in case of failure you can determine the last <code class="language-plaintext highlighter-rouge">echo</code> statement displayed to troubleshoot the script.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"Processing file </span><span class="k">${</span><span class="nv">fq</span><span class="k">}</span><span class="s2">"</span>
</code></pre></div></div>

<blockquote>
  <p>You can also use <code class="language-plaintext highlighter-rouge">set -x</code>:</p>

  <p><code class="language-plaintext highlighter-rouge">set -x</code> is a debugging tool that will make bash display the command before executing it. In case of an issue with the commands in the shell script, this type of debugging lets you quickly pinpoint the step that is throwing an error. Often, tools will display the error that caused the program to stop running, so keep this in mind for times when you are running into issues where this is not available. You can turn this functionality off by saying <code class="language-plaintext highlighter-rouge">set +x</code></p>
</blockquote>

<h3 id="running-the-tools">Running the tools</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"Starting QC for </span><span class="k">${</span><span class="nv">samplename</span><span class="k">}</span><span class="s2">"</span>

<span class="c"># Run FastQC and move output to the appropriate folder</span>
fastqc <span class="nt">-o</span> <span class="k">${</span><span class="nv">fastqc_out</span><span class="k">}</span> <span class="k">${</span><span class="nv">fq</span><span class="k">}</span>


<span class="c"># Run STAR</span>
STAR <span class="nt">--runThreadN</span> <span class="k">${</span><span class="nv">cores</span><span class="k">}</span> <span class="nt">--genomeDir</span> <span class="k">${</span><span class="nv">genome</span><span class="k">}</span> <span class="nt">--readFilesIn</span> <span class="k">${</span><span class="nv">fq</span><span class="k">}</span> <span class="nt">--outFileNamePrefix</span> <span class="k">${</span><span class="nv">align_out</span><span class="k">}</span> <span class="nt">--outSAMtype</span> BAM SortedByCoordinate <span class="nt">--outSAMunmapped</span> Within <span class="nt">--outSAMattributes</span> Standard

<span class="c"># Run Qualimap</span>
qualimap rnaseq <span class="se">\</span>
<span class="nt">-outdir</span> <span class="k">${</span><span class="nv">qualimap_out</span><span class="k">}</span> <span class="se">\</span>
<span class="nt">-a</span> proportional <span class="se">\</span>
<span class="nt">-bam</span> <span class="k">${</span><span class="nv">align_out_bam</span><span class="k">}</span> <span class="se">\</span>
<span class="nt">-p</span> strand-specific-reverse <span class="se">\</span>
<span class="nt">-gtf</span> <span class="k">${</span><span class="nv">gtf</span><span class="k">}</span> <span class="se">\</span>
<span class="nt">--java-mem-size</span><span class="o">=</span>8G

<span class="c"># Run salmon</span>

<span class="nb">echo</span> <span class="s2">"Starting Salmon run for </span><span class="k">${</span><span class="nv">samplename</span><span class="k">}</span><span class="s2">"</span>

salmon quant <span class="nt">-i</span> <span class="k">${</span><span class="nv">transcriptome</span><span class="k">}</span> <span class="se">\</span>
<span class="nt">-p</span> <span class="k">${</span><span class="nv">cores</span><span class="k">}</span> <span class="se">\</span>
<span class="nt">-l</span> A <span class="se">\</span>
<span class="nt">-r</span> <span class="k">${</span><span class="nv">fq</span><span class="k">}</span> <span class="se">\</span>
<span class="nt">-o</span> <span class="k">${</span><span class="nv">salmon_out</span><span class="k">}</span> <span class="se">\</span>
<span class="nt">--seqBias</span> <span class="se">\</span>
<span class="nt">--useVBOpt</span>
</code></pre></div></div>

<h3 id="last-addition-to-the-script">Last addition to the script</h3>

<p>It is best practice to have the script <strong>usage</strong> specified at the top any script. This should have information such that when your future self, or a co-worker, uses the script they know what it will do and what input(s) are needed. For our script, we should have the following lines of comments right at the top after <code class="language-plaintext highlighter-rouge">#!/bin/bash/</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># This script takes a fastq file of RNA-seq data, runs FastQC, STAR, Qualimap and Salmon.</span>
<span class="c"># USAGE: sh rnaseq_analysis_on_input_file.sh &lt;name of fastq file&gt;</span>
</code></pre></div></div>

<p>It is okay to specify this after everything else is set up, since you will have most clarity about the script only once it is fully done.</p>

<h3 id="saving-and-running-script">Saving and running script</h3>

<p>To transfer the contents of the script from your laptop to O2, you can copy and paste the contents into a new file called <code class="language-plaintext highlighter-rouge">rnaseq_analysis_on_input_file.sh</code> using <code class="language-plaintext highlighter-rouge">vim</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd</span> ~/rnaseq/scripts/

<span class="nv">$ </span>vim rnaseq_analysis_on_input_file.sh 
</code></pre></div></div>

<blockquote>
  <p><em>Alternatively, you can save the script on your computer and transfer it to <code class="language-plaintext highlighter-rouge">~/rnaseq/scripts/</code> using FileZilla.</em></p>
</blockquote>

<p>We should all have an interactive session with 6 cores, so we can run the script as follows from the <code class="language-plaintext highlighter-rouge">~/rnaseq/</code> directory:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd</span> ~/rnaseq/     

<span class="nv">$ </span>sh scripts/rnaseq_analysis_on_input_file.sh ~/rnaseq/raw_data/Mov10_oe_1.subset.fq
</code></pre></div></div>

<h2 id="running-the-script-to-submit-jobs-in-parallel-to-the-slurm-scheduler">Running the script to submit jobs in parallel to the Slurm scheduler</h2>

<p>The above script will run in an interactive session <strong>one file at a time</strong>. But the whole point of writing this script was to run it on all files at once. How do you think we can do this?</p>

<p>To run the above script <strong>“in serial”</strong> for all of the files on a worker node via the job scheduler, we can create a separate submission script that will need 2 components:</p>

<ol>
  <li><strong>Slurm directives</strong> at the <strong>beginning</strong> of the script. This is so that the scheduler knows what resources we need in order to run our job on the compute node(s).</li>
  <li>a <strong><code class="language-plaintext highlighter-rouge">for</code></strong> loop that iterates through and runs the above script for all the fastq files.</li>
</ol>

<p>Below is what this second script (<code class="language-plaintext highlighter-rouge">rnaseq_analysis_on_allfiles.slurm</code>) would look like \(DO NOT RUN THIS\):</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="c">#SBATCH -p medium       # partition name</span>
<span class="c">#SBATCH -t 0-6:00       # hours:minutes runlimit after which job will be killed</span>
<span class="c">#SBATCH -c 6        # number of cores requested -- this needs to be greater than or equal to the number of cores you plan to use to run your job</span>
<span class="c">#SBATCH --mem 8G</span>
<span class="c">#SBATCH --job-name STAR_mov10       # Job name</span>
<span class="c">#SBATCH -o %j.out           # File to which standard out will be written</span>
<span class="c">#SBATCH -e %j.err       # File to which standard err will be written</span>

<span class="c"># this `for` loop, will take the fastq files as input and run the script for all of them one after the other. </span>
<span class="k">for </span>fq <span class="k">in</span> ~/rnaseq/raw_data/<span class="k">*</span>.fq
<span class="k">do
  </span><span class="nb">echo</span> <span class="s2">"running analysis on </span><span class="k">${</span><span class="nv">fq</span><span class="k">}</span><span class="s2">"</span>
  sh ~/rnaseq/scripts/rnaseq_analysis_on_input_file.sh <span class="k">${</span><span class="nv">fq</span><span class="k">}</span>
<span class="k">done</span>
</code></pre></div></div>

<p><strong>But we don’t want to run the analysis on these 6 samples one after the other!</strong> We want to run them “in parallel” as 6 separate jobs.</p>

<p><strong>Note:</strong> If you create and run the above script, or something similar to it, i.e. with Slurm directives at the top, you should give the script name <code class="language-plaintext highlighter-rouge">.run</code> or <code class="language-plaintext highlighter-rouge">.slurm</code> as the extension. This will make it obvious that it is meant to submit jobs to the Slurm scheduler.</p>

<hr />

<p><strong>Exercise</strong></p>

<p>How would you run <code class="language-plaintext highlighter-rouge">rnaseq_analysis_on_allfiles.slurm</code>, i.e. the above script?</p>

<hr />

<h2 id="parallelizing-the-analysis-for-efficiency">Parallelizing the analysis for efficiency</h2>

<p>Parallelization will save you a lot of time with real (large) datasets. To parallelize our analysis, we will still need to write a second script that will call the script we just wrote that takes a fastq file as input (rnaseq_analysis_on_input_file.sh). We will still use a <code class="language-plaintext highlighter-rouge">for</code> loop, but we will be creating a regular shell script and we will be specifying the Slurm directives differently.</p>

<blockquote>
  <p>Alternatively, this could also be done using a <strong><em>Slurm array</em></strong>, which lets you submit a collection of similar jobs easily and quickly. You can learn more about Slurm arrays <a href="https://hbctraining.github.io/Training-modules/Intermediate_shell/lessons/arrays_in_slurm.html">here</a>.</p>
</blockquote>

<p>Use <code class="language-plaintext highlighter-rouge">vim</code> to start a new shell script called <code class="language-plaintext highlighter-rouge">rnaseq_analysis_on_allfiles-for_slurm.sh</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>vim rnaseq_analysis_on_allfiles_for-slurm.sh
</code></pre></div></div>

<p>This script loops through the same files as in the previous (demo) script, but the command being submitted within the <code class="language-plaintext highlighter-rouge">for</code> loop is <code class="language-plaintext highlighter-rouge">sbatch</code> with Slurm directives specified on the same line:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#! /bin/bash</span>

<span class="k">for </span>fq <span class="k">in</span> ~/rnaseq/raw_data/<span class="k">*</span>.fq
<span class="k">do

</span>sbatch <span class="nt">-p</span> short <span class="nt">-t</span> 0-2:00 <span class="nt">-c</span> 6 <span class="nt">--job-name</span> rnaseq-workflow <span class="nt">--mem</span> 8G <span class="nt">--wrap</span><span class="o">=</span><span class="s2">"sh ~/rnaseq/scripts/rnaseq_analysis_on_input_file.sh </span><span class="k">${</span><span class="nv">fq</span><span class="k">}</span><span class="s2">"</span>
<span class="nb">sleep </span>1 <span class="c"># wait 1 second between each job submission</span>
  
<span class="k">done</span>
</code></pre></div></div>

<blockquote>
  <p>Please note that after the <code class="language-plaintext highlighter-rouge">sbatch</code> directives the command <code class="language-plaintext highlighter-rouge">sh ~/rnaseq/scripts/rnaseq_analysis_on_input_file.sh ${fq}</code> is in quotes.</p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd</span> ~/rnaseq/scripts/
<span class="nv">$ </span>sh rnaseq_analysis_on_allfiles_for-slurm.sh
</code></pre></div></div>

<p>What you should see on the output of your screen would be the jobIDs that are returned from the scheduler for each of the jobs that your script submitted.</p>

<p>You can use <code class="language-plaintext highlighter-rouge">O2sacct</code> to check progress. And we can check if there are any additional files in our analysis folder.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>O2sacct

<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-l</span> /n/scratch/users/r/<span class="nv">$USER</span>/rnaseq_hbc-workshop/
</code></pre></div></div>

<p>Don’t forget about the <code class="language-plaintext highlighter-rouge">scancel</code> command, should something go wrong and you need to cancel your jobs.</p>

<blockquote>
  <p><strong>NOTE:</strong> All job schedulers are similar, but not the same. Once you understand how one works, you can transition to another one without too much trouble. They all have their pros and cons which are considered by the system administrators when picking one for a given HPC environment. Some examples of other job schedulers are LSF, SGE, PBS/Torque.</p>
</blockquote>

<hr />

<p><em>This lesson has been developed by members of the teaching team at the <a href="http://bioinformatics.sph.harvard.edu/">Harvard Chan Bioinformatics Core (HBC)</a>. These are open access materials distributed under the terms of the <a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution license</a> (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</em></p>


      <footer class="site-footer">
        
          <span class="site-footer-owner"><a href="https://github.com/esallychang/modified-intro-to-rnaseq-hpc">modified-intro-to-rnaseq-hpc</a> is maintained by <a href="https://github.com/esallychang">esallychang</a>.</span>
        
        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span>
      </footer>
    </main>
  </body>
</html>
